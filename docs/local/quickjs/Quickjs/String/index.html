<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>String (docs.local.quickjs.Quickjs.String)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../../index.html">Index</a> &#x00BB; <a href="../../../../index.html">docs</a> &#x00BB; <a href="../../../index.html">local</a> &#x00BB; <a href="../../index.html">quickjs</a> &#x00BB; <a href="../index.html">Quickjs</a> &#x00BB; String</nav><header class="odoc-preamble"><h1>Module <code><span>Quickjs.String</span></code></h1><p>JavaScript String built-in object</p><p>This module mirrors the JavaScript String API with prototype methods for string manipulation. All methods use UTF-16 semantics for indices.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#javascript-vs-ocaml-semantics">JavaScript vs OCaml Semantics</a></li></ul></nav></div><div class="odoc-content"><h3 id="javascript-vs-ocaml-semantics"><a href="#javascript-vs-ocaml-semantics" class="anchor"></a>JavaScript vs OCaml Semantics</h3><p>This library follows JavaScript semantics in most cases to ensure compatibility with the ECMA-262 specification:</p><ul><li><b>Indices</b>: All string indices are UTF-16 code unit positions, not byte positions. A string containing an emoji has length 2 (surrogate pair).</li></ul><ul><li><b>Not-found values</b>: Methods like <code>index_of</code> return <code>-1</code> when not found (JavaScript convention), not <code>option</code> (OCaml convention). This matches JavaScript's String.prototype.indexOf().</li></ul><ul><li><b>Character access</b>: Methods like <code>char_code_at</code> return <code>int option</code> (OCaml convention) for bounds checking, since OCaml does not have JavaScript's implicit NaN coercion.</li></ul><ul><li><b>Negative indices</b>: Methods like <code>slice</code> support negative indices counting from the end, matching JavaScript behavior.</li></ul><div class="odoc-spec"><div class="spec type anchored" id="type-normalization"><a href="#type-normalization" class="anchor"></a><code><span><span class="keyword">type</span> normalization</span><span> = </span></code><ol><li id="type-normalization.NFC" class="def variant constructor anchored"><a href="#type-normalization.NFC" class="anchor"></a><code><span>| </span><span><span class="constructor">NFC</span></span></code></li><li id="type-normalization.NFD" class="def variant constructor anchored"><a href="#type-normalization.NFD" class="anchor"></a><code><span>| </span><span><span class="constructor">NFD</span></span></code></li><li id="type-normalization.NFKC" class="def variant constructor anchored"><a href="#type-normalization.NFKC" class="anchor"></a><code><span>| </span><span><span class="constructor">NFKC</span></span></code></li><li id="type-normalization.NFKD" class="def variant constructor anchored"><a href="#type-normalization.NFKD" class="anchor"></a><code><span>| </span><span><span class="constructor">NFKD</span></span></code></li></ol></div><div class="spec-doc"><p>Unicode normalization forms</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_valid_utf8"><a href="#val-is_valid_utf8" class="anchor"></a><code><span><span class="keyword">val</span> is_valid_utf8 : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_valid_utf8 s</code> returns <code>true</code> if <code>s</code> contains only valid UTF-8 byte sequences. Use this for strict validation before processing untrusted input.</p><p>Note: All functions in this module handle invalid UTF-8 gracefully by replacing malformed sequences with U+FFFD (replacement character).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Prototype"><a href="#module-Prototype" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Prototype/index.html">Prototype</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>String.prototype methods</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lowercase_char"><a href="#val-lowercase_char" class="anchor"></a><code><span><span class="keyword">val</span> lowercase_char : <span><a href="../../../../stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> list</span></span></code></div><div class="spec-doc"><p><code>lowercase_char c</code> converts a single character to lowercase. May return multiple characters for special cases.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uppercase_char"><a href="#val-uppercase_char" class="anchor"></a><code><span><span class="keyword">val</span> uppercase_char : <span><a href="../../../../stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> list</span></span></code></div><div class="spec-doc"><p><code>uppercase_char c</code> converts a single character to uppercase. May return multiple characters (e.g., ß -&gt; SS).</p></div></div></div></body></html>
